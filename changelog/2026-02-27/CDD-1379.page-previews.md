# CDD-1379 - Page Previews

**Date:** 2026-02-27

**Ticket:** https://ukhsa.atlassian.net/browse/CDD-1379?search_id=055fe61d-bee9-48d9-80bc-ffb0f1c26b76&referrer=quick-find

**Authors:** Jean-Pierre Fouche

**Impact:** Affects all pages - broad testing required

**Testing:** Comprehensive unit tests supplied.  UAT needed.


## Summary

Allow editors of headless composite pages to click a **Preview** button that immediately redirects them to the external frontend application, rather than opening the built-in Wagtail iframe preview.  Preview URLs include a short-lived signed token so the frontend can safely fetch draft content from the CMS.

## Architecture

### Component Flow Diagram

```
Editor Browser             Wagtail Admin (CMS)         Django CMS API              Next.js Frontend
      |                            |                            |                             |
1.    |---- Load page editor ----->|                            |                             |
      |                            |                            |                             |
2.    |<--- Render Preview button -|                            |                             |
      |     href=/admin/preview-to-frontend/{page_id}/          |                             |
3.    |    Preview button visible  |                            |                             |
      |                            |                            |                             |
4.    | Click Preview              |                            |                             |
5.    |---- GET /admin/preview-to-frontend/{page_id} ---------->|                             |
      |                            |                            | 6. Build signed token +     |
      |                            |                            |    frontend preview URL     |
7.    |<--- 302 Location: /preview?page_id=...&token=... -------|                             |
      |                            |                            |                             |
8.    |---- Follow 302 to frontend preview URL ---------------------------------------------->|
      |                            |                            |                             |
9.    |                            |                            |<--- GET /api/drafts/{id} ---|
      |                            |                            |     Authorization: Bearer   |
      |                            |                            |     <token>                 |
10.   |                            |                            |--- draft JSON ------------->|
      |                            |                            |                             |
11.   |<---- Rendered preview page -----------------------------------------------------------|
      |                            |                            |                             |
```

### Component Responsibilities

**Wagtail Admin (CMS)**
- Renders Preview button in page editor header via `frontend_preview_button` and `add_frontend_preview_action` hooks
- Routes preview clicks to `PreviewToFrontendRedirectView`

**PreviewToFrontendRedirectView** (`cms/dashboard/views.py`)
- Generates signed token payload containing:
  - `page_id`: Database ID of the page being previewed
  - `slug`: URL-friendly page identifier
  - `editor_id`: ID of the user requesting preview
  - `iat`: Issued-at timestamp
  - `exp`: Expiration timestamp (120 seconds from issue)
- Signs payload using Django's `signing.dumps()` with salt `"preview-token"`
- Constructs frontend preview URL with token in querystring
- Issues HTTP 302 redirect to frontend

**Django CMS API** (`cms/dashboard/viewsets.py`)
- Extends existing `/api/drafts/{id}/` endpoint with token validation
- Extracts Bearer token from `Authorization` header
- Verifies token signature and expiry using matching salt
- Validates `page_id` in token matches requested page ID
- Returns HTTP 401 for invalid/expired tokens
- Returns draft page JSON on successful validation

**Next.js Frontend**
- Receives redirect with token in URL
- Fetches draft content from CMS API with token in Authorization header
- Renders preview page with unpublished content
- Handles token expiry gracefully

### Security Considerations

- **Token TTL**: 120-second expiry limits exposure window
- **HMAC signing**: Tokens cryptographically signed, cannot be forged
- **Salt isolation**: Preview tokens use dedicated salt, separate from session tokens
- **Bearer vs querystring**: Token transmitted in Authorization header to API (reduces logging exposure), though initially passed via querystring in redirect (acceptable for short-lived tokens)
- **No replay attacks**: Each token includes `iat` timestamp and specific `page_id`, limiting reuse scope

## Overview

There are two areas of concern:

* [Rendering the Preview Button](#rendering-the-preview-button)
* [Handling Preview Requests](#handling-preview-requests)

## Rendering the Preview Button

### Code-level sequence diagram

**Page editor loads and renders the Preview button in the Action Menu**

```
wagtail_hooks.frontend_preview_button(page, user, next_url, view_name)
  -> reverse("cms_preview_to_frontend", args=[page.pk])
  -> return [Button("Preview", url=admin_url, ...)]
```

**User clicks Preview button**

```
Browser GET /admin/preview-to-frontend/{pk}/
  -> PreviewToFrontendRedirectView.get(request, pk)
      -> get_object_or_404(Page, pk=pk).specific
      -> page.permissions_for_user(request.user).can_edit()
      -> payload = {
           "page_id",
           "editor_id",
           "iat",
           "exp",
         }
      -> token = django.core.signing.dumps(payload, salt=PAGE_PREVIEWS_TOKEN_SALT)
      -> frontend_url = PAGE_PREVIEWS_FRONTEND_URL_TEMPLATE.format(page_id=..., token=...)
      -> return redirect(frontend_url)

Frontend GET /api/drafts/{id}/  (Authorization: Bearer <token>)
  -> CMSDraftPagesViewSet.detail_view(request, pk)
      -> loads(token, salt=PAGE_PREVIEWS_TOKEN_SALT)
      -> validate payload["page_id"] == pk
      -> validate payload["exp"] >= now
      -> instance = self.get_object().get_latest_revision_as_object()
      -> serializer = self.get_serializer(instance)
      -> return Response(serializer.data)
```

### Enabling preview per page type

Preview visibility is controlled centrally in `cms/dashboard/wagtail_hooks.py`
via the page attribute `custom_preview_enabled`.

Example:

```python
class UKHSAPage(Page):
    custom_preview_enabled: bool = True


class CommonPage(UKHSAPage):
    custom_preview_enabled: bool = False


class UKHSARootPage(Page):
    custom_preview_enabled: bool = False
```

How it works:

* `frontend_preview_button` and `add_frontend_preview_action` both read
  `page.custom_preview_enabled` directly.
* If `custom_preview_enabled` is `True`, the custom Preview button/action is shown.
* If `custom_preview_enabled` is `False`, no custom Preview button/action is shown.

Implementation notes:

* `UKHSAPage` defaults `custom_preview_enabled` to `True`.
* Only exceptional classes need explicit overrides.
* Current explicit overrides: `CommonPage=False`, `UKHSARootPage=False`.

To enable preview for a page type:

1. Set `custom_preview_enabled` on the page model as needed.
2. Run `tests/unit/cms/dashboard/test_preview_views_and_hooks.py` (and related preview tests)
   to confirm behavior.

**Preview Button**

**UKHSAPage.is_previewable**
   * This custom base class attribute toggles our custom preview functionality.  Note that the similarly named `is_previewable()` function handles the Wagtail framework preview functionality and has been **disabled**.
   * Returns `False` to disable Wagtail's built-in preview iframe panel.
     When `is_previewable()` returns `False`, Wagtail does not create the
     `PreviewSidePanel`, avoiding template-missing errors in this headless CMS.
     Custom hooks provide external preview buttons independently.

**Admin hooks & redirect view**
   * **Why redirect through the CMS:** By using a redirect, the CMS delays token signing until the user clicks Preview, rather than rendering it into the button HTML. This provides two benefits: it avoids unnecessary token exposure in the page source, and prevents the token from expiring while the user is still viewing the editor. This approach allows us to use an extremely narrow TTL windowâ€”just the time needed for the user to click through to the frontend and render the page (seconds, rather than minutes). 
   * Added `PreviewToFrontendRedirectView` in `cms/dashboard/views.py`.
     * builds a payload (`page_id`, `editor_id`, `iat`, `exp`)
     * signs with `django.core.signing.dumps(..., salt="preview-token")`
     * redirects to a configurable frontend URL containing the signed token
   * Registered the view under `cms_preview_to_frontend` via
     `register_admin_urls` hook.
   * Wagtail hook `register_page_header_buttons` returns a `Button` that
     points at the admin redirect URL (with fallback) when `view_name ==
     "edit"`.
   * Added `construct_page_action_menu` hook inserting a custom
     `ActionMenuItem` as the primary action, ensuring the preview button is
     visible in the page editor header.

**Tests**
   * Added a comprehensive suite of unit tests covering every change:
     - `frontend_preview_button` returns a `Button` in edit mode and falls
       back to the template URL when reverse fails.
     - Redirect view permissions, success path, and URL tokenization logic.
     - `add_frontend_preview_action` handles missing/PK-less pages, reverse
       failures, and even exceptions during menu insertion.
   * An integration test validates the complete preview flow end-to-end
     (`tests/integration/cms/test_api.py`), verifying Bearer token
     authentication and draft content retrieval.

**Documentation & comments**
   * Added explanatory comments throughout hooks file explaining rationale
     and behaviour.
   * Updated `UKHSAPage.is_previewable` docstring to explain why it
     returns `False` for this headless CMS implementation.

**Enabling the UI**

The CMS iframe preview is inappropriate for this scenario enabline preview and results in missing-template errors.  Nevertheless, editors still need a convenient way to view draft pages in context, so we use custom Wagtail hooks to add preview buttons that redirect to the external Next.js application with an HMAC token.  Setting `is_previewable=False` prevents Wagtail from creating the built-in preview panel, while the custom hooks provide external preview functionality independently.

## Handling Preview Requests

**Preview API**
   * Implemented token verification directly in the existing drafts endpoint
     (`/api/drafts/{id}/`) in `cms/dashboard/viewsets.py`.
     - Expects a Bearer token in the `Authorization` header.
     - Verifies the token using the application-configured salt and TTL.
     - Verifies `page_id` in token payload matches the `{id}` path parameter.
     - Returns HTTP 401 for missing, invalid or expired tokens.
   * Removed the separate `pages/preview/<slug>` endpoint.

**Why a separate serializer is needed**
  * The draft endpoint is implemented via a Wagtail API ViewSet and serializes unpublished revisions.
  * `CMSDraftPagesSerializer` keeps preview output stable while adapting Wagtail serializer expectations for draft payloads.

**Gotchas and how we handle them**
   * **Unmapped relational fields** (e.g. `latest_revision`) can trigger
     `KeyError: serializer_class`.
     - **Handling**: fallback to read-only `PrimaryKeyRelatedField` for
       relations without child serializer mappings.
   * **Context-dependent Wagtail fields** can expect ViewSet internals and fail with errors like missing `seen_types`/`base_queryset`.
     - **Handling**: rely on ViewSet serializer context and avoid problematic fields in the draft serializer output.
   * **Nested page relation fields** (`parent`, `alias_of`) can recursively invoke Wagtail serializer paths that require full router/viewset state.
     - **Handling**: remove those fields (and other context-heavy meta fields such as `type`/`detail_url`) from the preview serializer output.
   * **Static serializer vs dynamic Wagtail serializer assumptions** can drift.
     - **Handling**: explicitly define serializer attributes used by Wagtail internals and cover these branches with dedicated unit tests.

**Why**
  * **Reuse existing drafts endpoint**: Implementing token validation directly on `/api/drafts/{id}/` keeps one canonical draft read path while adding preview-specific auth checks.
   * **Headers vs querystrings**: Bearer tokens in `Authorization` headers are preferred over querystring parameters because querystrings are more likely to be captured in logs, analytics, and intermediary infrastructure. Using headers reduces accidental token exposure and aligns with standard API authentication practices.  Note that for ease of implementation, these headers are implemented only on the CMS API, and not on the preview button, where querystrings are used.  It is possible that we would improve the Preview button in a future version.
   * **Why serializer-level fixes were needed**: the crashes happened in Wagtail/DRF field construction, not in URL routing or token checks.  Addressing serializer integration was the durable fix.

---

See also:
* [tests/unit/cms/dashboard/test_preview_views_and_hooks.py](../tests/unit/cms/dashboard/test_preview_views_and_hooks.py)
* [cms/dashboard/wagtail_hooks.py](../cms/dashboard/wagtail_hooks.py)
* [cms/dashboard/views.py](../cms/dashboard/views.py)
* [cms/composite/models.py](../cms/composite/models.py)
